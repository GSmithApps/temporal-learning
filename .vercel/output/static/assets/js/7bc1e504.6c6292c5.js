"use strict";(self.webpackChunktemporal_learning=self.webpackChunktemporal_learning||[]).push([[1408],{5997:(e,t,n)=>{n.d(t,{Zt:()=>r,yT:()=>o});var i=n(7294),a=n(2004);const o=function(e){let{url:t,loop:n,playing:o}=e;return i.createElement("div",{className:"relative rounded-lg shadow-lg",style:{position:"relative",paddingTop:"56.25%",marginBottom:20}},i.createElement(a.Z,{url:t,loop:n,playing:o,width:"100%",height:"100%",controls:!0,style:{position:"absolute",top:0,left:0}}))};n(4673);var l=n(3612);function r(){return i.createElement(l.Z,{type:"info",title:"WORK IN PROGRESS"},i.createElement("p",null,"This tutorial is a work in progress. Some sections may be incomplete, out of date, or missing. We're working to update it."))}},5944:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>l,metadata:()=>s,toc:()=>u});var i=n(3117),a=(n(7294),n(3905)),o=(n(5162),n(4866),n(5997));const l={id:"subscription-tutorial",sidebar_position:1,keywords:["PHP","temporal","sdk","tutorial","subscriptions","signals"],tags:["PHP","SDK"],last_update:{date:new Date("2021-10-01T00:00:00.000Z")},title:"Subscription walkthrough with Temporal in PHP",description:"In this tutorial you'll build a realistic monthly subscription payments workflow that can be canceled while it runs.",image:"/img/temporal-logo-twitter-card.png"},r=void 0,s={unversionedId:"tutorials/php/subscriptions/subscription-tutorial",id:"tutorials/php/subscriptions/subscription-tutorial",title:"Subscription walkthrough with Temporal in PHP",description:"In this tutorial you'll build a realistic monthly subscription payments workflow that can be canceled while it runs.",source:"@site/docs/tutorials/php/subscriptions/index.md",sourceDirName:"tutorials/php/subscriptions",slug:"/tutorials/php/subscriptions/",permalink:"/tutorials/php/subscriptions/",draft:!1,tags:[{label:"PHP",permalink:"/tags/php"},{label:"SDK",permalink:"/tags/sdk"}],version:"current",lastUpdatedAt:1633046400,formattedLastUpdatedAt:"Oct 1, 2021",sidebarPosition:1,frontMatter:{id:"subscription-tutorial",sidebar_position:1,keywords:["PHP","temporal","sdk","tutorial","subscriptions","signals"],tags:["PHP","SDK"],last_update:{date:"2021-10-01T00:00:00.000Z"},title:"Subscription walkthrough with Temporal in PHP",description:"In this tutorial you'll build a realistic monthly subscription payments workflow that can be canceled while it runs.",image:"/img/temporal-logo-twitter-card.png"},sidebar:"tutorialSidebar",previous:{title:"Create a trip booking system with the Saga pattern and Temporal in PHP",permalink:"/tutorials/php/booking_saga/"},next:{title:"Example applications",permalink:"/examples/"}},c={},u=[{value:"Introduction",id:"introduction",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Create the Workflow",id:"create-the-workflow",level:2},{value:"Start/End Trial",id:"startend-trial",level:3},{value:"Receive Cancellations",id:"receive-cancellations",level:2},{value:"Monthly Subscription Handling",id:"monthly-subscription-handling",level:2},{value:"Conclusion",id:"conclusion",level:2}],p={toc:u};function d(e){let{components:t,...l}=e;return(0,a.kt)("wrapper",(0,i.Z)({},p,l,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Temporal PHP SDK",src:n(766).Z,width:"902",height:"254"})),(0,a.kt)(o.Zt,{mdxType:"OutdatedNotice"}),(0,a.kt)("h2",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"In this tutorial you'll build a realistic monthly subscription payments workflow that can be canceled while it runs."),(0,a.kt)("p",null,"Our task is to write a Workflow for a limited time Subscription (eg a 12-month Phone plan) that satisfies the following conditions:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"When the user signs up, ",(0,a.kt)("strong",{parentName:"li"},"send a welcome email")," and start a free trial for ",(0,a.kt)("inlineCode",{parentName:"li"},"TrialPeriod"),"."),(0,a.kt)("li",{parentName:"ol"},"When the ",(0,a.kt)("inlineCode",{parentName:"li"},"TrialPeriod")," expires: charge a monthly fee."),(0,a.kt)("li",{parentName:"ol"},"When charging a fee send a corresponding email."),(0,a.kt)("li",{parentName:"ol"},"At any point while subscription (or trial) is ongoing, be able to cancel subscription with sending a ",(0,a.kt)("strong",{parentName:"li"},"cancellation email"),".")),(0,a.kt)("p",null,"Of course, this all has to be fault-tolerant, scalable to millions of customers, testable, maintainable, observable... and so on!"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"To skip straight to a fully working example, you can check out the ",(0,a.kt)("a",{parentName:"strong",href:"https://github.com/temporalio/samples-php/tree/master/app/src/Subscription"},"Subscription Workflow repo")),"."),(0,a.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/getting_started/php/dev_environment/"},"Set up a local development environment for developing Temporal applications using PHP")),(0,a.kt)("li",{parentName:"ul"},"Review the ",(0,a.kt)("a",{parentName:"li",href:"/getting_started/php/hello_world_in_php/"},"Hello World in PHP tutorial")," and understood the basics of getting a Temporal PHP SDK project up and running. ")),(0,a.kt)("h2",{id:"create-the-workflow"},"Create the Workflow"),(0,a.kt)("p",null,"The whole process of ",(0,a.kt)("em",{parentName:"p"},'"creating a subscription"')," is too complicated; we need to break it into small manageable peaces and build it up incrementally."),(0,a.kt)("p",null,"We can start building the whole thing step by step. Start with subscribing a user (",(0,a.kt)("inlineCode",{parentName:"p"},"subscribe($userId)"),"):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-php"},"#[WorkflowInterface]\ninterface SubscriptionWorkflowInterface\n{\n    #[WorkflowMethod]\n    public function subscribe(string $userID);\n}\n")),(0,a.kt)("p",null,"Having this interface we can start building our app. First, we need a console command - a PHP script that takes some input and\nstarts the workflow."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-php"},"class SubscribeCommand extends Command\n{\n    protected const NAME = 'subscribe:start';\n    protected const DESCRIPTION = 'Execute Subscription\\SubscriptionWorkflow with custom user ID';\n\n    protected const ARGUMENTS = [\n        ['userID', InputArgument::REQUIRED, 'Unique user ID']\n    ];\n\n    public function execute(InputInterface $input, OutputInterface $output)\n    {\n        $userID = $input->getArgument('userID');\n\n        $workflow = $this->workflowClient->newWorkflowStub(\n            SubscriptionWorkflowInterface::class,\n            WorkflowOptions::new()\n                ->withWorkflowId('subscription:' . $userID)\n                ->withWorkflowIdReusePolicy(IdReusePolicy::POLICY_ALLOW_DUPLICATE)\n        );\n\n        $output->writeln(\"Start <comment>SubscriptionWorkflow</comment>... \");\n\n        try {\n            $run = $this->workflowClient->start($workflow, $userID);\n        } catch (WorkflowExecutionAlreadyStartedException $e) {\n            $output->writeln('<fg=red>Already running</fg=red>');\n            return self::SUCCESS;\n        }\n\n        $output->writeln(\n            sprintf(\n                'Started: WorkflowID=<fg=magenta>%s</fg=magenta>',\n                $run->getExecution()->getID(),\n            )\n        );\n\n        return self::SUCCESS;\n    }\n}\n")),(0,a.kt)("p",null,"In the snippet above we grab userId as an input and use it to start the workflow. Also, userId is used as a workflow identifier (",(0,a.kt)("inlineCode",{parentName:"p"},"'subscription:' . $userID"),"). Later it will be used to cancel the subscription. Now, let's implement the workflow - a long-running process that represents user subscription business process."),(0,a.kt)("h3",{id:"startend-trial"},"Start/End Trial"),(0,a.kt)("p",null,"The first requirement is about starting trial period and sending emails: when the trial period starts and ends.  We don't have any activities yet, but we can start coding and think about the interface. Assume that we have ",(0,a.kt)("inlineCode",{parentName:"p"},"AccountActivityInterface")," which handles all the subscription components:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-php"},"class SubscriptionWorkflow implements SubscriptionWorkflowInterface\n{\n    private $account;\n\n    public function __construct()\n    {\n        $this->account = Workflow::newActivityStub(\n            AccountActivityInterface::class,\n            ActivityOptions::new()\n                ->withScheduleToCloseTimeout(CarbonInterval::seconds(2))\n        );\n    }\n\n    public function subscribe(string $userID)\n    {\n        // ...\n    }\n}\n")),(0,a.kt)("admonition",{title:"Activity implementation",type:"info"},(0,a.kt)("p",{parentName:"admonition"},"We consider activity implementation as an implementation detail, so it is out of scope. When building this subscription workflow we will walk through the business process and use only activity interfaces. It is up to you to implement all other details.")),(0,a.kt)("p",null,"The method ",(0,a.kt)("inlineCode",{parentName:"p"},"subscribe(string $userID)")," contains all the business logic. First, we send an email that the trial period has started. Then we start a trial for (let's say) 30 days. Once the period ends, we send a corresponding email:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-php"},"public function subscribe(string $userID)\n{\n    yield $this->account->sendWelcomeEmail($userID);\n    yield Workflow::timer(CarbonInterval::month());\n    yield $this->account->sendEndOfTrialEmail($userID);\n}\n")),(0,a.kt)("p",null,"As you can see, we delegate email sending to the activity and use timer to wait for a trial period to finish."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"In other words, what happens here? The workflow sends the first email, then it ",(0,a.kt)("em",{parentName:"li"},"sleeps")," for 30 days, and then send one more email. Looks very elegant, right?"),(0,a.kt)("li",{parentName:"ul"},"It looks like a regular PHP ",(0,a.kt)("inlineCode",{parentName:"li"},"sleep()")," call. But inside the workflow we cannot use any functions that may cause side effects, thus we use ",(0,a.kt)("inlineCode",{parentName:"li"},"Workflow::timer")," here.")),(0,a.kt)("admonition",{title:"Comparing Temporal's Timer vs PHP's sleep()",type:"note"},(0,a.kt)("p",{parentName:"admonition"},"Using ",(0,a.kt)("inlineCode",{parentName:"p"},"Workflow::timer")," is safer because it is persisted to Temporal Server with a server-side timer.\nIf any part of your system (App, Worker, even Temporal Server itself) crashes, then after restart it will continue right from the crash and not from scratch.\nIt means that if the workflow has been waiting for 29 days and then crashes, it will be able to recover and continue from where it left off.\nThis is not possible when using native PHP ",(0,a.kt)("inlineCode",{parentName:"p"},"sleep()")," function.")),(0,a.kt)("h2",{id:"receive-cancellations"},"Receive Cancellations"),(0,a.kt)("p",null,"Per Requirement 4, users can cancel during the trial.  Once the trial period or subscription is cancelled, we should email the user."),(0,a.kt)("p",null,"How can we implement subscription cancellation?  There are several ways to do it, but the simplest is just to use Temporal's API to cancel the entire workflow.  We will need a separate console command for cancellation:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-php"},"class CancelCommand extends Command\n{\n    protected const NAME = 'subscribe:cancel';\n    protected const DESCRIPTION = 'Cancel Subscription\\SubscriptionWorkflow for user ID';\n\n    protected const ARGUMENTS = [\n        ['userID', InputArgument::REQUIRED, 'Unique user ID']\n    ];\n\n    public function execute(InputInterface $input, OutputInterface $output)\n    {\n        $userID = $input->getArgument('userID');\n        $workflow = $this->workflowClient->newUntypedRunningWorkflowStub('subscription:' . $userID);\n\n        try {\n            $workflow->cancel();\n            $output->writeln('Cancelled');\n        } catch (WorkflowNotFoundException $e) {\n            $output->writeln('<fg=red>Already stopped</fg=red>');\n        }\n\n        return self::SUCCESS;\n    }\n")),(0,a.kt)("p",null,"This command accepts ",(0,a.kt)("inlineCode",{parentName:"p"},"$userId")," as an input argument, then fetches the workflow with id of ",(0,a.kt)("inlineCode",{parentName:"p"},"subscription:$userID")," and tries to cancel it."),(0,a.kt)("p",null,"Next, we can handle cancellation within the running workflow.  Once the running workflow is cancelled ",(0,a.kt)("inlineCode",{parentName:"p"},"CancelledFailure")," exception is thrown.  We can catch it and send an email like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-php"},"public function subscribe(string $userID)\n{\n    yield $this->account->sendWelcomeEmail($userID);\n\n    try {\n        yield Workflow::timer(CarbonInterval::month());\n        yield $this->account->sendEndOfTrialEmail($userID);\n    } catch (CanceledFailure $exception) {\n         yield Workflow::asyncDetached(fn() => $this->account->sendSorryToSeeYouGoEmail($userID));\n    }\n}\n")),(0,a.kt)("p",null,"Here we catch ",(0,a.kt)("inlineCode",{parentName:"p"},"CanceledFailure")," and continue with activity to send a cancellation email."),(0,a.kt)("p",null,"Why do we use Temporal's ",(0,a.kt)("inlineCode",{parentName:"p"},"Workflow::asyncDetached()")," instead of plain PHP ",(0,a.kt)("inlineCode",{parentName:"p"},"yield"),'?\nWe are using "native way" to cancel a business process (a workflow) here.\nWhen a workflow is cancelled, all internal coroutines will be also cancelled.\n',(0,a.kt)("strong",{parentName:"p"},"The email should be sent even if the main workflow is already closed."),"\nThus, we need to run it into a detached coroutine, that doesn't belong to the workflow."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Workflow::asyncDetached()")," does this job: everything inside the callback will be executed inside the detached coroutine, that doesn't belong to the calling workflow. Exactly what we need here.\nHaving that actually we can handle any cancellations: trial or monthly subscription.\nSo, let's continue and finally implement subscription workflow."),(0,a.kt)("admonition",{title:"Why not use a Signal?",type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Another way to cancel the subscription is to send a ",(0,a.kt)("a",{parentName:"p",href:"https://docs.temporal.io/dev-guide/php/features#signals"},"signal")," to the workflow. For example, we\ncan wait with condition:"),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre",className:"language-php"},"yield Workflow::awaitWithTimeout(\n    CarbonInterval::month(),\n    fn() => $this->isCancelled\n);\n")),(0,a.kt)("p",{parentName:"admonition"},"It is a valid approach, but cancelling the workflow with ",(0,a.kt)("inlineCode",{parentName:"p"},"cancel()")," method we may be 100% sure that all internal\nprocesses and activities will be gracefully shut down.")),(0,a.kt)("h2",{id:"monthly-subscription-handling"},"Monthly Subscription Handling"),(0,a.kt)("p",null,"At this moment we have a working trial period that can be cancelled. To finish our workflow we need to add several steps:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"charge a monthly fee"),(0,a.kt)("li",{parentName:"ul"},"send monthly charged email"),(0,a.kt)("li",{parentName:"ul"},"process subscription cancellation")),(0,a.kt)("p",null,"If we assume that the subscription period is 30 days, and it should last until it is manually cancelled, then we can use an infinite loop here (subject to ",(0,a.kt)("a",{parentName:"p",href:"https://docs.temporal.io/workflows/#event-history"},"Event History Limits"),", but don't worry about that for a monthly workflow).\nWe \"endlessly\" wait for 30 days and charge monthly fee.\nAlso, don't forget about the trial period at the beginning."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-php"},"public function subscribe(string $userID)\n{\n    yield $this->account->sendWelcomeEmail($userID);\n\n    try {\n        $isTrialPeriod = true;\n        while (true) {\n            yield Workflow::timer(CarbonInterval::month());\n            yield $this->account->chargeMonthlyFee($userID);\n\n            if ($isTrialPeriod === true) {\n                yield $this->account->sendEndOfTrialEmail($userID);\n                $isTrialPeriod = false;\n                continue;\n            }\n\n            yield $this->account->sendMonthlyChargeEmail($userID);\n        }\n    } catch (CanceledFailure $exception) {\n        yield $this->account->sendSorryToSeeYouGoEmail($userID);\n    }\n}\n")),(0,a.kt)("p",null,"In the snippet above we have a new flag ",(0,a.kt)("inlineCode",{parentName:"p"},"$isTrialPeriod = true"),". After the first loop iteration we finish the trial:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"charge monthly fee"),(0,a.kt)("li",{parentName:"ul"},"change '$isTrialPeriod' flag to ",(0,a.kt)("inlineCode",{parentName:"li"},"false"),"."),(0,a.kt)("li",{parentName:"ul"},"a corresponding email is sent"),(0,a.kt)("li",{parentName:"ul"},"move to the next loop iteration")),(0,a.kt)("p",null,"On the next iteration we again wait for 30 days, charge monthly fee and send email.\nThe last thing we need to do is to handle subscription cancellation, where we just send our cancellation email, but you can do whatever other cleanup tasks you want."),(0,a.kt)("p",null,'If you want to test things you can use this "dummy" activity implementation that logs each step to the screen:'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-php"},"class AccountActivity implements AccountActivityInterface\n{\n    private LoggerInterface $logger;\n\n    public function __construct()\n    {\n        $this->logger = new Logger();\n    }\n\n    public function sendWelcomeEmail(string $userID): void\n    {\n        $this->log('Send welcome email to %s', $userID);\n    }\n\n    public function chargeMonthlyFee(string $userID): void\n    {\n        $this->log('Charge %s of monthly fee', $userID);\n    }\n\n    public function sendEndOfTrialEmail(string $userID): void\n    {\n        $this->log('Send %s end of trial email', $userID);\n    }\n\n    public function sendMonthlyChargeEmail(string $userID): void\n    {\n        $this->log('Send %s monthly charge email', $userID);\n    }\n\n    public function sendSorryToSeeYouGoEmail(string $userID): void\n    {\n        $this->log('Send %s sorry to see you go email', $userID);\n    }\n\n    public function processSubscriptionCancellation(string $userID): void\n    {\n        $this->log('Cancel subscription for %s', $userID);\n    }\n\n    /**\n     * @param string $message\n     * @param mixed ...$arg\n     */\n    private function log(string $message, ...$arg)\n    {\n        // by default all error logs are forwarded to the application server log and docker log\n        $this->logger->debug(sprintf($message, ...$arg));\n    }\n}\n")),(0,a.kt)("p",null,"Register this Activity and add it to your workflow."),(0,a.kt)("h2",{id:"conclusion"},"Conclusion"),(0,a.kt)("p",null,"You have created a complete subscription workflow that can:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"handle trial periods"),(0,a.kt)("li",{parentName:"ul"},"charge monthly fee every N days"),(0,a.kt)("li",{parentName:"ul"},"handle subscription cancellations")),(0,a.kt)("p",null,"With Temporal, you can write a relatively complex business process with fewer lines of code, and the Workflow code provides you with a high-level view of the business process without digging into deeper details."))}d.isMDXComponent=!0},766:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/banner_php-6b22d4e7d2062dc50defc5f46c25c536.png"}}]);