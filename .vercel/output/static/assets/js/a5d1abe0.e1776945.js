"use strict";(self.webpackChunktemporal_learning=self.webpackChunktemporal_learning||[]).push([[6653],{5997:(e,t,r)=>{r.d(t,{Zt:()=>l,yT:()=>o});var a=r(7294),n=r(2004);const o=function(e){let{url:t,loop:r,playing:o}=e;return a.createElement("div",{className:"relative rounded-lg shadow-lg",style:{position:"relative",paddingTop:"56.25%",marginBottom:20}},a.createElement(n.Z,{url:t,loop:r,playing:o,width:"100%",height:"100%",controls:!0,style:{position:"absolute",top:0,left:0}}))};r(4673);var i=r(3612);function l(){return a.createElement(i.Z,{type:"info",title:"WORK IN PROGRESS"},a.createElement("p",null,"This tutorial is a work in progress. Some sections may be incomplete, out of date, or missing. We're working to update it."))}},7708:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var a=r(3117),n=(r(7294),r(3905)),o=(r(5162),r(4866),r(5997));const i={sidebar_position:4,tags:["Go","Tutorial"],slug:"build-an-ecommerce-app-with-temporal-part-4-rest-api",title:"Building an eCommerce web app with Temporal and Go, Part 4: REST API",keywords:["go","golang","temporal","sdk","tutorial","workflows","api","rest","ecommerce"],last_update:{author:"Valeri Karpov",date:new Date("2021-09-14T00:00:00.000Z")},image:"/img/temporal-logo-twitter-card.png"},l=void 0,s={unversionedId:"tutorials/go/ecommerce/part4",id:"tutorials/go/ecommerce/part4",title:"Building an eCommerce web app with Temporal and Go, Part 4: REST API",description:"Temporal Go SDK",source:"@site/docs/tutorials/go/ecommerce/part4.md",sourceDirName:"tutorials/go/ecommerce",slug:"/tutorials/go/ecommerce/build-an-ecommerce-app-with-temporal-part-4-rest-api",permalink:"/tutorials/go/ecommerce/build-an-ecommerce-app-with-temporal-part-4-rest-api",draft:!1,tags:[{label:"Go",permalink:"/tags/go"},{label:"Tutorial",permalink:"/tags/tutorial"}],version:"current",lastUpdatedBy:"Valeri Karpov",lastUpdatedAt:1631577600,formattedLastUpdatedAt:"Sep 14, 2021",sidebarPosition:4,frontMatter:{sidebar_position:4,tags:["Go","Tutorial"],slug:"build-an-ecommerce-app-with-temporal-part-4-rest-api",title:"Building an eCommerce web app with Temporal and Go, Part 4: REST API",keywords:["go","golang","temporal","sdk","tutorial","workflows","api","rest","ecommerce"],last_update:{author:"Valeri Karpov",date:"2021-09-14T00:00:00.000Z"},image:"/img/temporal-logo-twitter-card.png"},sidebar:"tutorialSidebar",previous:{title:"Building an eCommerce web app with Temporal and Go, Part 3: Testing",permalink:"/tutorials/go/ecommerce/build-an-ecommerce-app-with-temporal-part-3-testing"},next:{title:"Build an email subscription workflow with Temporal and Go",permalink:"/tutorials/go/subscriptions/"}},p={},d=[{value:"Introduction",id:"introduction",level:2},{value:"API Setup",id:"api-setup",level:2},{value:"Handler Functions",id:"handler-functions",level:2},{value:"PUT Requests and Signals",id:"put-requests-and-signals",level:2},{value:"Conclusion",id:"conclusion",level:2}],u={toc:d};function c(e){let{components:t,...i}=e;return(0,n.kt)("wrapper",(0,a.Z)({},u,i,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"Temporal Go SDK",src:r(161).Z,width:"902",height:"254"})),(0,n.kt)(o.Zt,{mdxType:"OutdatedNotice"}),(0,n.kt)("h2",{id:"introduction"},"Introduction"),(0,n.kt)("p",null,"In ",(0,n.kt)("a",{parentName:"p",href:"/tutorials/go/ecommerce/build-an-ecommerce-app-with-temporal-part-1"},"Part 1"),", ",(0,n.kt)("a",{parentName:"p",href:"/tutorials/go/ecommerce/build-an-ecommerce-app-with-temporal-part-2-reminder-emails"},"Part 2"),", and ",(0,n.kt)("a",{parentName:"p",href:"/tutorials/go/ecommerce/build-an-ecommerce-app-with-temporal-part-3-testing"},"Part 3"),", you built and tested a shopping cart with an abandoned cart email notification using long-lived Workflows.\nWorkflows, Activities, and Temporal's testing utilities make it easy to build and maintain features that involve external services and time, like sending an email reminder when a user hasn't touched their cart in a while."),(0,n.kt)("p",null,"Thus far, you've worked only with the Temporal SDK via ",(0,n.kt)("a",{parentName:"p",href:"/getting_started/go/hello_world_in_go/#workflow-starter"},"starters")," and ",(0,n.kt)("a",{parentName:"p",href:"https://docs.temporal.io/dev-guide/go/testing"},"unit tests"),", which invoke the Temporal SDK directly."),(0,n.kt)("p",null,"In this tutorial, you'll see how you can build a RESTful API on top of Temporal Workflows, so you can create web apps and mobile apps that store data in Temporal."),(0,n.kt)("h2",{id:"api-setup"},"API Setup"),(0,n.kt)("p",null,"For this tutorial, you'll be using ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/bojanz/httpx"},"httpx")," along with ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/gorilla/mux"},"mux")," for routing and ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/gorilla/handlers"},"handlers")," for CORS."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "context"\n    "github.com/bojanz/httpx"\n    "github.com/gorilla/handlers"\n    "github.com/gorilla/mux"\n    "net/http"\n    "os"\n)\n\nfunc main() {\n    var err error\n\n    // Set up CORS for frontend\n    var cors = handlers.CORS(handlers.AllowedHeaders([]string{"X-Requested-With", "Content-Type", "Authorization"}), handlers.AllowedMethods([]string{"GET", "POST", "PUT", "HEAD", "OPTIONS"}), handlers.AllowedOrigins([]string{"*"}))\n\n    http.Handle("/", cors(r))\n    server := httpx.NewServer(":"+HTTPPort, http.DefaultServeMux)\n    server.WriteTimeout = time.Second * 240\n\n    err = server.Start()\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n')),(0,n.kt)("p",null,"The API endpoints will use ",(0,n.kt)("a",{parentName:"p",href:"https://docs.temporal.io/dev-guide/go/foundations#start-workflow-execution"},"Temporal Client methods")," to create Workflows, and execute Signals and Queries.\nFor the purposes of this app, HTTP GET requests execute Queries, HTTP PUT or PATCH requests send Signals, and HTTP POST requests create new Workflows."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},'// Create a new cart\nr.Handle("/cart", http.HandlerFunc(CreateCartHandler)).Methods("POST")\n// Get the state of an existing cart\nr.Handle("/cart/{workflowID}", http.HandlerFunc(GetCartHandler)).Methods("GET")\n\n// Add a new item to the cart\nr.Handle("/cart/{workflowID}/add", http.HandlerFunc(AddToCartHandler)).Methods("PUT")\n// Remove an item from the cart\nr.Handle("/cart/{workflowID}/remove", http.HandlerFunc(RemoveFromCartHandler)).Methods("PUT")\n// Update the cart\'s associated email address\nr.Handle("/cart/{workflowID}/email", http.HandlerFunc(UpdateEmailHandler)).Methods("PUT")\n// Check out\nr.Handle("/cart/{workflowID}/checkout", http.HandlerFunc(CheckoutHandler)).Methods("PUT")\n')),(0,n.kt)("p",null,"In this case, the API server and the ",(0,n.kt)("a",{parentName:"p",href:"https://docs.temporal.io/workers"},"Worker")," are separate processes.\nThe API server is just an intermediary between the Temporal server and your API server's clients.\nThe event history representing the cart is stored in the Temporal server."),(0,n.kt)("h2",{id:"handler-functions"},"Handler Functions"),(0,n.kt)("p",null,"First, let's take a look at the ",(0,n.kt)("inlineCode",{parentName:"p"},"POST /cart")," endpoint. Since we've chosen to represent an individual shopping cart as a Workflow, the ",(0,n.kt)("inlineCode",{parentName:"p"},"CreateCartHandler()")," function will create a new Workflow using ",(0,n.kt)("inlineCode",{parentName:"p"},"ExecuteWorkflow()"),".\nFor the purposes of this app, we need to make sure each ",(0,n.kt)("inlineCode",{parentName:"p"},"POST /cart")," call creates a Workflow creates a unique ",(0,n.kt)("inlineCode",{parentName:"p"},"workflowID"),"."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},'func CreateCartHandler(w http.ResponseWriter, r *http.Request) {\n  // In production you should use uuids or something similar, but the\n  // current time is enough for this example. Make sure the Workflow ID\n  // is unique every time the user creates a new cart!\n    workflowID := "CART-" + fmt.Sprintf("%d", time.Now().Unix())\n\n    options := client.StartWorkflowOptions{\n        ID:        workflowID,\n        TaskQueue: "CART_TASK_QUEUE",\n    }\n\n    cart := app.CartState{Items: make([]app.CartItem, 0)}\n    we, err := temporal.ExecuteWorkflow(context.Background(), options, app.CartWorkflow, cart)\n    if err != nil {\n        WriteError(w, err)\n        return\n    }\n\n  // Return the `workflowID` so clients can use it with other endpoints\n    res := make(map[string]interface{})\n    res["cart"] = cart\n    res["workflowID"] = we.GetID()\n\n    w.WriteHeader(http.StatusCreated)\n    json.NewEncoder(w).Encode(res)\n}\n')),(0,n.kt)("p",null,"Now you have a ",(0,n.kt)("inlineCode",{parentName:"p"},"POST /cart")," endpoint that creates a new empty cart, and returns the ",(0,n.kt)("inlineCode",{parentName:"p"},"workflowID")," that uniquely identifies this Workflow."),(0,n.kt)("p",null,"The next endpoint is ",(0,n.kt)("inlineCode",{parentName:"p"},"GET /cart/{workflowID}"),", which returns the current state of the cart with the given ",(0,n.kt)("inlineCode",{parentName:"p"},"WorkflowID"),".\nBelow is the ",(0,n.kt)("inlineCode",{parentName:"p"},"GetCartHandler()")," function, which gets the ",(0,n.kt)("inlineCode",{parentName:"p"},"workflowID")," from the URL and executes a Query for the current state of the cart."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},'func GetCartHandler(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    response, err := temporal.QueryWorkflow(context.Background(), vars["workflowID"], "", "getCart")\n    if err != nil {\n        WriteError(w, err)\n        return\n    }\n    var res interface{}\n    if err := response.Get(&res); err != nil {\n        WriteError(w, err)\n        return\n    }\n\n    w.WriteHeader(http.StatusOK)\n    json.NewEncoder(w).Encode(res)\n}\n')),(0,n.kt)("h2",{id:"put-requests-and-signals"},"PUT Requests and Signals"),(0,n.kt)("p",null,"For this app, HTTP PUT requests correspond to Temporal Signals.\nThat means, in addition to the ",(0,n.kt)("inlineCode",{parentName:"p"},"workflowID"),", you need to send Signal arguments.\nRemember that ",(0,n.kt)("inlineCode",{parentName:"p"},"shared.go")," contains an ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/temporalio/temporal-ecommerce/blob/5c4e0142e3571398d972c80b3fa7cdbe7a5db42b/shared.go#L64-L67"},(0,n.kt)("inlineCode",{parentName:"a"},"AddToCartSignal")," struct")," which is what the ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/temporalio/temporal-ecommerce/blob/5c4e0142e3571398d972c80b3fa7cdbe7a5db42b/workflow.go#L52-L71"},"cart Workflow's Signal handler expects"),":"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"type AddToCartSignal struct {\n    Route string\n    Item  CartItem\n}\n")),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"PUT /cart/{workflowID}/add")," handler needs to convert the HTTP request body into an ",(0,n.kt)("inlineCode",{parentName:"p"},"AddToCartSignal")," as shown below."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},'func AddToCartHandler(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    var item app.CartItem\n    err := json.NewDecoder(r.Body).Decode(&item)\n    if err != nil {\n        WriteError(w, err)\n        return\n    }\n\n    update := app.AddToCartSignal{Route: app.RouteTypes.ADD_TO_CART, Item: item}\n\n    err = temporal.SignalWorkflow(context.Background(), vars["workflowID"], "", "ADD_TO_CART_CHANNEL", update)\n    if err != nil {\n        WriteError(w, err)\n        return\n    }\n\n    w.WriteHeader(http.StatusOK)\n    res := make(map[string]interface{})\n    res["ok"] = 1\n    json.NewEncoder(w).Encode(res)\n}\n')),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"PUT /cart/{workflowID}/remove")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"PUT /cart/{workflowID}/email")," handlers are almost identical, except they send ",(0,n.kt)("inlineCode",{parentName:"p"},"RemoveFromCartSignal")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"UpdateEmailSignal"),", not ",(0,n.kt)("inlineCode",{parentName:"p"},"AddToCartSignal"),"."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},'func UpdateEmailHandler(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n\n    var body UpdateEmailRequest\n    err := json.NewDecoder(r.Body).Decode(&body)\n    if err != nil {\n        WriteError(w, err)\n        return\n    }\n\n    updateEmail := app.UpdateEmailSignal{Route: app.RouteTypes.UPDATE_EMAIL, Email: body.Email}\n\n    err = temporal.SignalWorkflow(context.Background(), vars["workflowID"], "", "UPDATE_CART_CHANNEL", updateEmail)\n    if err != nil {\n        WriteError(w, err)\n        return\n    }\n\n    w.WriteHeader(http.StatusOK)\n    res := make(map[string]interface{})\n    res["ok"] = 1\n    json.NewEncoder(w).Encode(res)\n}\n')),(0,n.kt)("h2",{id:"conclusion"},"Conclusion"),(0,n.kt)("p",null,"You can build a RESTful API on top of Temporal by making HTTP POST requests create Workflows, GET requests execute Queries, and PUT requests execute Signals."),(0,n.kt)("p",null,"This isn't the only way you can build a RESTful API with Temporal, but this pattern works well if you use long-lived Workflows to store user data."),(0,n.kt)("p",null,"Because all of the work of updating your shopping cart happens in the Worker process, you can scale your API servers independently of your Worker processes, and rely on the Temporal server to handle the distributed computing."))}c.isMDXComponent=!0},161:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/banner_go-9b8733250036c66a86bf103fb4a01804.png"}}]);