"use strict";(self.webpackChunktemporal_learning=self.webpackChunktemporal_learning||[]).push([[5169],{5997:(e,t,n)=>{n.d(t,{Zt:()=>s,yT:()=>r});var a=n(7294),o=n(2004);const r=function(e){let{url:t,loop:n,playing:r}=e;return a.createElement("div",{className:"relative rounded-lg shadow-lg",style:{position:"relative",paddingTop:"56.25%",marginBottom:20}},a.createElement(o.Z,{url:t,loop:n,playing:r,width:"100%",height:"100%",controls:!0,style:{position:"absolute",top:0,left:0}}))};n(4673);var i=n(3612);function s(){return a.createElement(i.Z,{type:"info",title:"WORK IN PROGRESS"},a.createElement("p",null,"This tutorial is a work in progress. Some sections may be incomplete, out of date, or missing. We're working to update it."))}},269:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var a=n(3117),o=(n(7294),n(3905)),r=(n(5162),n(4866),n(5997));const i={sidebar_position:3,tags:["Go","Tutorial"],slug:"build-an-ecommerce-app-with-temporal-part-3-testing",keywords:["go","golang","temporal","sdk","tutorial","workflows","testing","ecommerce"],title:"Building an eCommerce web app with Temporal and Go, Part 3: Testing",last_update:{author:"Valeri Karpov",date:new Date("2021-07-14T00:00:00.000Z")},image:"/img/temporal-logo-twitter-card.png"},s=void 0,l={unversionedId:"tutorials/go/ecommerce/part3",id:"tutorials/go/ecommerce/part3",title:"Building an eCommerce web app with Temporal and Go, Part 3: Testing",description:"Temporal Go SDK",source:"@site/docs/tutorials/go/ecommerce/part3.md",sourceDirName:"tutorials/go/ecommerce",slug:"/tutorials/go/ecommerce/build-an-ecommerce-app-with-temporal-part-3-testing",permalink:"/tutorials/go/ecommerce/build-an-ecommerce-app-with-temporal-part-3-testing",draft:!1,tags:[{label:"Go",permalink:"/tags/go"},{label:"Tutorial",permalink:"/tags/tutorial"}],version:"current",lastUpdatedBy:"Valeri Karpov",lastUpdatedAt:1626220800,formattedLastUpdatedAt:"Jul 14, 2021",sidebarPosition:3,frontMatter:{sidebar_position:3,tags:["Go","Tutorial"],slug:"build-an-ecommerce-app-with-temporal-part-3-testing",keywords:["go","golang","temporal","sdk","tutorial","workflows","testing","ecommerce"],title:"Building an eCommerce web app with Temporal and Go, Part 3: Testing",last_update:{author:"Valeri Karpov",date:"2021-07-14T00:00:00.000Z"},image:"/img/temporal-logo-twitter-card.png"},sidebar:"tutorialSidebar",previous:{title:"Building an eCommerce web app with Temporal and Go, Part 2: Reminder Emails",permalink:"/tutorials/go/ecommerce/build-an-ecommerce-app-with-temporal-part-2-reminder-emails"},next:{title:"Building an eCommerce web app with Temporal and Go, Part 4: REST API",permalink:"/tutorials/go/ecommerce/build-an-ecommerce-app-with-temporal-part-4-rest-api"}},u={},c=[{value:"Introduction",id:"introduction",level:2},{value:"30 Minute Video Version",id:"30-minute-video-version",level:2},{value:"Testing Setup",id:"testing-setup",level:2},{value:"Querying Workflows in tests",id:"querying-workflows-in-tests",level:2},{value:"Signaling Workflows in tests",id:"signaling-workflows-in-tests",level:2},{value:"Sending multiple Signals to Workflows in tests",id:"sending-multiple-signals-to-workflows-in-tests",level:3},{value:"Mocking Activities and Controlling Time",id:"mocking-activities-and-controlling-time",level:2},{value:"Conclusion",id:"conclusion",level:2}],m={toc:c};function p(e){let{components:t,...i}=e;return(0,o.kt)("wrapper",(0,a.Z)({},m,i,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Temporal Go SDK",src:n(161).Z,width:"902",height:"254"})),(0,o.kt)(r.Zt,{mdxType:"OutdatedNotice"}),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"In ",(0,o.kt)("a",{parentName:"p",href:"/tutorials/go/ecommerce/build-an-ecommerce-app-with-temporal-part-1"},"Part 1")," and ",(0,o.kt)("a",{parentName:"p",href:"/tutorials/go/ecommerce/build-an-ecommerce-app-with-temporal-part-2-reminder-emails"},"Part 2"),", you built out a shopping cart with an abandoned cart email notification using long-lived Workflows."),(0,o.kt)("p",null,"Using Workflows and Activities, you can easily build features that would be tricky in a traditional RESTful API, like sending an email reminder when a user hasn't touched their cart in a while."),(0,o.kt)("p",null,"Temporal Workflows do more than make working with time easy, they also make your code easier to test.  Temporal provides testing utilities that help you stub out external services and programmatically advance time, which lets you unit test your Workflows. For an example, take a look at how ",(0,o.kt)("a",{parentName:"p",href:"https://temporal.io/case-studies/descript-case-study"},"Descript uses Temporal"),"."),(0,o.kt)("p",null,"In this blog post, you'll explore how to use Temporal's testing utilities to write fast unit tests for the shopping cart from Part 1 and Part 2."),(0,o.kt)("h2",{id:"30-minute-video-version"},"30 Minute Video Version"),(0,o.kt)("p",null,"You can watch a video version of this tutorial as well:"),(0,o.kt)(r.yT,{url:"https://www.youtube.com/watch?v=-GKxFDQSlEU",mdxType:"ResponsivePlayer"}),(0,o.kt)("h2",{id:"testing-setup"},"Testing Setup"),(0,o.kt)("p",null,"The following is a basic setup for testing a Temporal Workflow using ",(0,o.kt)("inlineCode",{parentName:"p"},"go test")," and ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/stretchr/testify"},"Testify")," based on ",(0,o.kt)("a",{parentName:"p",href:"https://docs.temporal.io/dev-guide/go/testing"},"Temporal's Go testing docs"),"."),(0,o.kt)("p",null,"You can find the full source code for the test suite in the ",(0,o.kt)("inlineCode",{parentName:"p"},"workflow_test.go")," file."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'package app\n\nimport (\n    "context"\n    "testing"\n\n    "github.com/stretchr/testify/mock"\n    "github.com/stretchr/testify/suite"\n\n    "go.temporal.io/sdk/activity"\n    "go.temporal.io/sdk/testsuite"\n    "go.temporal.io/sdk/client"\n\n    "time"\n)\n\ntype UnitTestSuite struct {\n    suite.Suite\n    testsuite.WorkflowTestSuite\n\n    env *testsuite.TestWorkflowEnvironment\n}\n\nfunc (s *UnitTestSuite) SetupTest() {\n    // You are responsible for calling `NewTestWorkflowEnvironment()` to initialize\n    // Temporal\'s testing utilities, but you can also add any other setup you need\n    // in this function.\n    s.env = s.NewTestWorkflowEnvironment()\n}\n\nfunc (s *UnitTestSuite) AfterTest(suiteName, testName string) {\n    s.env.AssertExpectations(s.T())\n}\n\nfunc TestUnitTestSuite(t *testing.T) {\n    suite.Run(t, new(UnitTestSuite))\n}\n')),(0,o.kt)("p",null,"The most important property is the ",(0,o.kt)("inlineCode",{parentName:"p"},"env")," property, which is an instance of ",(0,o.kt)("a",{parentName:"p",href:"https://pkg.go.dev/go.temporal.io/temporal/internal#TestWorkflowEnvironment"},"Temporal's ",(0,o.kt)("inlineCode",{parentName:"a"},"TestWorkflowEnvironment")," struct"),".\nA ",(0,o.kt)("inlineCode",{parentName:"p"},"TestWorkflowEnvironment")," provides utilities for testing Workflows, including executing Workflows, mocking Activities, and Signaling and Querying test Workflows."),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/stretchr/testify"},"testify package")," also provides utilities for organizing tests, including setting up and tearing down test suites using ",(0,o.kt)("inlineCode",{parentName:"p"},"SetupTest()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"AfterTest()"),".\nFor example, you can define multiple test suites as shown below."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"type UnitTestSuite struct {\n    suite.Suite\n    testsuite.WorkflowTestSuite\n\n    env *testsuite.TestWorkflowEnvironment\n}\n\nfunc (s *UnitTestSuite) SetupTest() {\n    s.env = s.NewTestWorkflowEnvironment()\n}\n\nfunc (s *UnitTestSuite) AfterTest(suiteName, testName string) {\n    s.env.AssertExpectations(s.T())\n}\n\ntype IntegrationTestSuite struct {\n    suite.Suite\n    testsuite.WorkflowTestSuite\n\n    env *testsuite.TestWorkflowEnvironment\n}\n\nfunc (s *IntegrationTestSuite) SetupTest() {\n    s.env = s.NewTestWorkflowEnvironment()\n}\n\nfunc (s *IntegrationTestSuite) AfterTest(suiteName, testName string) {\n    s.env.AssertExpectations(s.T())\n}\n")),(0,o.kt)("h2",{id:"querying-workflows-in-tests"},"Querying Workflows in tests"),(0,o.kt)("p",null,"Remember that, in this app, a shopping cart is a Workflow.\nTo get the current state of the shopping cart, you send a Query to the Workflow, and to update the cart you send a Signal to the Workflow."),(0,o.kt)("p",null,"The below code shows how you can use ",(0,o.kt)("inlineCode",{parentName:"p"},"env.QueryWorkflow()")," to send a Query to the shopping cart Workflow."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'func (s *UnitTestSuite) Test_QueryCart() {\n    cart := CartState{Items: make([]CartItem, 0)}\n\n    s.env.ExecuteWorkflow(CartWorkflow, cart)\n\n  // Note that `ExecuteWorkflow()` is blocking: the Workflow is done by the time\n  // the test gets to this line.\n    s.True(s.env.IsWorkflowCompleted())\n\n  // Send a query to the Workflow and assert that the shopping cart is still empty\n    res, err := s.env.QueryWorkflow("getCart")\n    s.NoError(err)\n    err = res.Get(&cart)\n    s.NoError(err)\n    s.Equal(0, len(cart.Items))\n}\n')),(0,o.kt)("p",null,"Note that the above code Queries the Workflow ",(0,o.kt)("em",{parentName:"p"},"after the Workflow is done"),".\nIn order to interact with the Workflow via Queries and Signals while the Workflow is running, you should use the test environment's ",(0,o.kt)("inlineCode",{parentName:"p"},"RegisterDelayedCallback()")," function as shown below.\nMake sure you call ",(0,o.kt)("inlineCode",{parentName:"p"},"RegisterDelayedCallback()")," ",(0,o.kt)("em",{parentName:"p"},"before")," ",(0,o.kt)("inlineCode",{parentName:"p"},"ExecuteWorkflow()"),", otherwise Temporal will execute the entire Workflow without executing the callback."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'func (s *UnitTestSuite) Test_IntermediateQuery() {\n    cart := CartState{Items: make([]CartItem, 0)}\n\n  // Register a callback to execute after 1 millisecond elapses in the Workflow.\n    s.env.RegisterDelayedCallback(func() {\n        res, err := s.env.QueryWorkflow("getCart")\n        s.NoError(err)\n        err = res.Get(&cart)\n        s.NoError(err)\n        s.Equal(len(cart.Items), 0)\n    }, time.Millisecond*1)\n\n    s.env.ExecuteWorkflow(CartWorkflow, cart)\n\n    s.True(s.env.IsWorkflowCompleted())\n}\n')),(0,o.kt)("p",null,"You can Query a Workflow after it is completed, but you can't Signal a Workflow after it is completed."),(0,o.kt)("h2",{id:"signaling-workflows-in-tests"},"Signaling Workflows in tests"),(0,o.kt)("p",null,"So in order to Signal a Workflow from your tests, you need to use ",(0,o.kt)("inlineCode",{parentName:"p"},"RegisterDelayedCallback()"),".\nJust remember that Signaling is asynchronous, so you need to add a separate ",(0,o.kt)("inlineCode",{parentName:"p"},"RegisterDelayedCallback()")," to read the result of your Signal using a Query.\nFor example, below is a test case for the ",(0,o.kt)("inlineCode",{parentName:"p"},"AddToCart()")," method."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'func (s *UnitTestSuite) Test_AddToCart() {\n    cart := CartState{Items: make([]CartItem, 0)}\n\n  // First callback at 1ms: query to make sure the cart is empty, and signal to add an item.\n    s.env.RegisterDelayedCallback(func() {\n        res, err := s.env.QueryWorkflow("getCart")\n        s.NoError(err)\n        err = res.Get(&cart)\n        s.NoError(err)\n        s.Equal(len(cart.Items), 0)\n\n        update := AddToCartSignal{\n            Route: RouteTypes.ADD_TO_CART,\n            Item: CartItem{ProductId: 1, Quantity: 1},\n        }\n        s.env.SignalWorkflow("cartMessages", update)\n    }, time.Millisecond*1)\n\n  // Second callback at 2ms: query to make sure the item is in the cart\n  // This needs to be a separate callback, `s.Equal(1, len(cart.Items))` would\n  // fail if it were in the 1ms callback.\n    s.env.RegisterDelayedCallback(func() {\n        res, err := s.env.QueryWorkflow("getCart")\n        s.NoError(err)\n        err = res.Get(&cart)\n        s.NoError(err)\n\n    s.Equal(1, len(cart.Items))\n    s.Equal(1, cart.Items[0].Quantity)\n    }, time.Millisecond*2)\n\n    s.env.ExecuteWorkflow(CartWorkflow, cart)\n\n    s.True(s.env.IsWorkflowCompleted())\n}\n')),(0,o.kt)("h3",{id:"sending-multiple-signals-to-workflows-in-tests"},"Sending multiple Signals to Workflows in tests"),(0,o.kt)("p",null,"Similarly, if you want to send a Query to check the state of the Workflow between Signals, you should put the Query in a separate ",(0,o.kt)("inlineCode",{parentName:"p"},"RegisterDelayedCallback()")," call.\nYou can move any Queries that don't have any Signals after them to after the ",(0,o.kt)("inlineCode",{parentName:"p"},"ExecuteWorkflow()")," call.\nFor example, below is a test case for the ",(0,o.kt)("inlineCode",{parentName:"p"},"RemoveFromCart()")," method."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'func (s *UnitTestSuite) Test_RemoveFromCart() {\n    cart := CartState{Items: make([]CartItem, 0)}\n\n    // Add 2 items to the cart\n    s.env.RegisterDelayedCallback(func() {\n        update := AddToCartSignal{\n            Route: RouteTypes.ADD_TO_CART,\n            Item: CartItem{ProductId: 1, Quantity: 2},\n        }\n        s.env.SignalWorkflow("cartMessages", update)\n    }, time.Millisecond*1)\n\n    // Query the current state and then remove 1 item from the cart\n    s.env.RegisterDelayedCallback(func() {\n        res, err := s.env.QueryWorkflow("getCart")\n        s.NoError(err)\n        err = res.Get(&cart)\n        s.NoError(err)\n        s.Equal(len(cart.Items), 1)\n        s.Equal(cart.Items[0].Quantity, 2)\n\n        update := AddToCartSignal{\n            Route: RouteTypes.REMOVE_FROM_CART,\n            Item: CartItem{ProductId: 1, Quantity: 1},\n        }\n        s.env.SignalWorkflow("cartMessages", update)\n    }, time.Millisecond*2)\n\n    s.env.ExecuteWorkflow(CartWorkflow, cart)\n\n    s.True(s.env.IsWorkflowCompleted())\n\n    // Since there\'s no more Signals, no need to put this Query in a\n    // `RegisterDelayedCallback()` call.\n    res, err := s.env.QueryWorkflow("getCart")\n    s.NoError(err)\n    err = res.Get(&cart)\n    s.NoError(err)\n    s.Equal(1, len(cart.Items))\n    s.Equal(cart.Items[0].Quantity, 1)\n}\n')),(0,o.kt)("p",null,"This covers testing the basic functionality of adding items to and removing items from the shopping cart.\nBut what about testing more sophisticated features, like testing that the Workflow sends an abandoned cart email after 10 minutes?"),(0,o.kt)("h2",{id:"mocking-activities-and-controlling-time"},"Mocking Activities and Controlling Time"),(0,o.kt)("p",null,"Temporal's test environment makes it easy to mock Activities, replacing them with a stubbed out function.\nFor example, the below test asserts that sending a checkout Signal calls the ",(0,o.kt)("inlineCode",{parentName:"p"},"CreateStripeCharge")," Activity with the correct receipt email using the test environment's ",(0,o.kt)("inlineCode",{parentName:"p"},"OnActivity()")," function."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'func (s *UnitTestSuite) Test_Checkout() {\n    cart := CartState{Items: make([]CartItem, 0)}\n\n    var a *Activities\n    sendTo := ""\n\n    s.env.OnActivity(a.CreateStripeCharge, mock.Anything, mock.Anything).Return(\n        func(_ context.Context, cart CartState) (error) {\n            sendTo = cart.Email\n            return nil\n        })\n\n    // Add a product to the cart\n    s.env.RegisterDelayedCallback(func() {\n        update := AddToCartSignal{\n            Route: RouteTypes.ADD_TO_CART,\n            Item: CartItem{ProductId: 1, Quantity: 1},\n        }\n        s.env.SignalWorkflow("cartMessages", update)\n    }, time.Millisecond*1)\n\n    // Check out\n    s.env.RegisterDelayedCallback(func() {\n        res, err := s.env.QueryWorkflow("getCart")\n        s.NoError(err)\n        err = res.Get(&cart)\n        s.NoError(err)\n        s.Equal(len(cart.Items), 1)\n        s.Equal(cart.Items[0].Quantity, 1)\n\n        update := CheckoutSignal{\n            Route: RouteTypes.CHECKOUT,\n            Email: "test@temporal.io",\n        }\n        s.env.SignalWorkflow("cartMessages", update)\n    }, time.Millisecond*2)\n\n    // Workflow should be completed after checking out\n    s.env.RegisterDelayedCallback(func() {\n        s.True(s.env.IsWorkflowCompleted())\n    }, time.Millisecond*3)\n\n    s.env.ExecuteWorkflow(CartWorkflow, cart)\n\n    s.Equal(sendTo, "test@temporal.io")\n}\n')),(0,o.kt)("p",null,"What about testing the abandoned cart email?\nNormally, testing the abandoned cart email is tricky because it involves waiting for 10 minutes.\nThe key insight is that Temporal's test environment advances time internally, and time in the test environment is ",(0,o.kt)("strong",{parentName:"p"},"not")," ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Elapsed_real_time"},"wall-clock time"),"."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"RegisterDelayedCallback()")," function ties into the test environment's internal notion of time.\nCalling ",(0,o.kt)("inlineCode",{parentName:"p"},"RegisterDelayedCallback(fn, time.Minute*5)")," does ",(0,o.kt)("strong",{parentName:"p"},"not")," tell the test environment to wait for 5 minutes of wall-clock time.\nThat means testing the abandoned cart email is easy: mock out the ",(0,o.kt)("inlineCode",{parentName:"p"},"SendAbandonedCartEmail()")," activity and use ",(0,o.kt)("inlineCode",{parentName:"p"},"RegisterDelayedCallback()")," with the ",(0,o.kt)("inlineCode",{parentName:"p"},"abandonedCartTimeout")," as shown below."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'func (s *UnitTestSuite) Test_AbandonedCart() {\n    cart := CartState{Items: make([]CartItem, 0)}\n\n    var a *Activities\n\n    sendTo := ""\n    s.env.OnActivity(a.SendAbandonedCartEmail, mock.Anything, mock.Anything).Return(\n        func(_ context.Context, _sendTo string) (error) {\n            sendTo = _sendTo\n            return nil\n        })\n\n    // Add a product to the cart\n    s.env.RegisterDelayedCallback(func() {\n        update := AddToCartSignal{\n            Route: RouteTypes.ADD_TO_CART,\n            Item: CartItem{ProductId: 1, Quantity: 1},\n        }\n        s.env.SignalWorkflow("cartMessages", update)\n\n        updateEmail := UpdateEmailSignal{\n            Route: RouteTypes.UPDATE_EMAIL,\n            Email: "abandoned_test@temporal.io",\n        }\n        s.env.SignalWorkflow("cartMessages", updateEmail)\n    }, time.Millisecond*1)\n\n    // Wait for 10 mins and make sure abandoned cart email has been sent. The extra\n    // 2ms is because signals are async, so the last change to the cart happens at 2ms.\n    s.env.RegisterDelayedCallback(func() {\n        s.Equal(sendTo, "abandoned_test@temporal.io")\n    }, abandonedCartTimeout + time.Millisecond*2)\n\n    s.env.ExecuteWorkflow(CartWorkflow, cart)\n\n    s.True(s.env.IsWorkflowCompleted())\n}\n')),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"Temporal's testing environment makes unit testing Workflows much less complex.  Sending Signals and Queries to the currently running Workflow with ",(0,o.kt)("inlineCode",{parentName:"p"},"RegisterDelayedCallback()")," is a low-friction approach. "),(0,o.kt)("p",null,"Most importantly, Temporal's testing environment provides utilities for mocking Activities and testing logic that executes after a delay.  That makes it less complicated to unit test Workflows that depend on external services or Workflows that involve long timeouts."),(0,o.kt)("p",null,"In the ",(0,o.kt)("a",{parentName:"p",href:"/tutorials/go/ecommerce/build-an-ecommerce-app-with-temporal-part-4-rest-api"},"next tutorial"),", you'll build a RESTful API on top of a Temporal Workflow."))}p.isMDXComponent=!0},161:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/banner_go-9b8733250036c66a86bf103fb4a01804.png"}}]);