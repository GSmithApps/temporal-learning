"use strict";(self.webpackChunktemporal_learning=self.webpackChunktemporal_learning||[]).push([[3494],{5997:(e,t,n)=>{n.d(t,{Zt:()=>l,yT:()=>r});var a=n(7294),o=n(2004);const r=function(e){let{url:t,loop:n,playing:r}=e;return a.createElement("div",{className:"relative rounded-lg shadow-lg",style:{position:"relative",paddingTop:"56.25%",marginBottom:20}},a.createElement(o.Z,{url:t,loop:n,playing:r,width:"100%",height:"100%",controls:!0,style:{position:"absolute",top:0,left:0}}))};n(4673);var i=n(3612);function l(){return a.createElement(i.Z,{type:"info",title:"WORK IN PROGRESS"},a.createElement("p",null,"This tutorial is a work in progress. Some sections may be incomplete, out of date, or missing. We're working to update it."))}},3552:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>m});var a=n(3117),o=(n(7294),n(3905)),r=(n(5162),n(4866),n(5997));const i={sidebar_position:2,tags:["Go","Tutorial"],slug:"build-an-ecommerce-app-with-temporal-part-2-reminder-emails",keywords:["go","golang","temporal","sdk","tutorial","sending email","workflows","ecommerce"],title:"Building an eCommerce web app with Temporal and Go, Part 2: Reminder Emails",last_update:{author:"Valeri Karpov",date:new Date("2021-06-08T00:00:00.000Z")},image:"/img/temporal-logo-twitter-card.png"},l=void 0,s={unversionedId:"tutorials/go/ecommerce/part2",id:"tutorials/go/ecommerce/part2",title:"Building an eCommerce web app with Temporal and Go, Part 2: Reminder Emails",description:"Temporal Go SDK",source:"@site/docs/tutorials/go/ecommerce/part2.md",sourceDirName:"tutorials/go/ecommerce",slug:"/tutorials/go/ecommerce/build-an-ecommerce-app-with-temporal-part-2-reminder-emails",permalink:"/tutorials/go/ecommerce/build-an-ecommerce-app-with-temporal-part-2-reminder-emails",draft:!1,tags:[{label:"Go",permalink:"/tags/go"},{label:"Tutorial",permalink:"/tags/tutorial"}],version:"current",lastUpdatedBy:"Valeri Karpov",lastUpdatedAt:1623110400,formattedLastUpdatedAt:"Jun 8, 2021",sidebarPosition:2,frontMatter:{sidebar_position:2,tags:["Go","Tutorial"],slug:"build-an-ecommerce-app-with-temporal-part-2-reminder-emails",keywords:["go","golang","temporal","sdk","tutorial","sending email","workflows","ecommerce"],title:"Building an eCommerce web app with Temporal and Go, Part 2: Reminder Emails",last_update:{author:"Valeri Karpov",date:"2021-06-08T00:00:00.000Z"},image:"/img/temporal-logo-twitter-card.png"},sidebar:"tutorialSidebar",previous:{title:"Build an eCommerce App With Temporal and Go, Part 1: Getting Started",permalink:"/tutorials/go/ecommerce/build-an-ecommerce-app-with-temporal-part-1"},next:{title:"Building an eCommerce web app with Temporal and Go, Part 3: Testing",permalink:"/tutorials/go/ecommerce/build-an-ecommerce-app-with-temporal-part-3-testing"}},c={},m=[{value:"Introduction",id:"introduction",level:2},{value:"Checking for an abandoned cart",id:"checking-for-an-abandoned-cart",level:2},{value:"Sending emails from an Activity",id:"sending-emails-from-an-activity",level:2},{value:"Conclusion",id:"conclusion",level:2}],p={toc:m};function d(e){let{components:t,...i}=e;return(0,o.kt)("wrapper",(0,a.Z)({},p,i,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Temporal Go SDK",src:n(161).Z,width:"902",height:"254"})),(0,o.kt)(r.Zt,{mdxType:"OutdatedNotice"}),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"In ",(0,o.kt)("a",{parentName:"p",href:"/tutorials/go/ecommerce/build-an-ecommerce-app-with-temporal-part-1"},"Part 1"),", you built out a simple shopping cart app using a long-living Workflow to track the state of the cart.\nInstead of storing the cart in a database, Temporal lets you represent the cart as a function invocation, using Signals to update the cart and Queries to get the state of the cart."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'func CartWorkflowExample(ctx workflow.Context, state CartState) error {\n    logger := workflow.GetLogger(ctx)\n\n    err := workflow.SetQueryHandler(ctx, "getCart", func(input []byte) (CartState, error) {\n        return state, nil\n    })\n    if err != nil {\n        logger.Info("SetQueryHandler failed.", "Error", err)\n        return err\n    }\n\n    channel := workflow.GetSignalChannel(ctx, "cartMessages")\n    selector := workflow.NewSelector(ctx)\n\n    selector.AddReceive(channel, func(c workflow.ReceiveChannel, _ bool) {\n        var signal interface{}\n        c.Receive(ctx, &signal)\n        state.Items = append(state.Items, CartItem{ProductId: 0, Quantity: 1})\n    })\n\n    for {\n        selector.Select(ctx)\n    }\n\n    return nil\n}\n')),(0,o.kt)("p",null,"The long-living Workflow pattern doesn't offer any substantial benefits in this simple CRUD app.\nHowever, some tasks are trivial to handle using the long-living Workflow pattern than in a traditional web application setup.\nAs an example, let's take a look at implementing an abandoned cart email notification system."),(0,o.kt)("h2",{id:"checking-for-an-abandoned-cart"},"Checking for an abandoned cart"),(0,o.kt)("p",null,"In eCommerce, an ",(0,o.kt)("a",{parentName:"p",href:"https://www.optimizely.com/optimization-glossary/shopping-cart-abandonment/#:~:text=Shopping%20cart%20abandonment%20is%20when,process%20before%20completing%20the%20purchase.&text=This%20rate%20will%20identify%20what,don't%20complete%20the%20purchase."},(0,o.kt)("em",{parentName:"a"},"abandoned")," shopping cart")," is a shopping cart that has items, but the user hasn't added\nany new items or checked out after a few hours."),(0,o.kt)("p",null,"The following is an example of an abandoned cart email that I recently received with an offer to incentivize checkout."),(0,o.kt)("img",{src:"https://codebarbarian-images.s3.amazonaws.com/shopping-cart.jpg"}),(0,o.kt)("p",null,"In a traditional web app architecture, abandoned cart notifications are tricky."),(0,o.kt)("p",null,"You need to use a job queue like ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Celery_(software)"},"Celery")," in Python or ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/RichardKnop/machinery"},"Machinery")," in GoLang. Then, you would schedule a job that checks if the cart is abandoned, and reschedule that job every time the cart is updated."),(0,o.kt)("p",null,"With Temporal, you don't need a separate job queue. Instead, you define a ",(0,o.kt)("em",{parentName:"p"},"Selector")," with two event handlers: one that responds to a Workflow signal and one that responds to a timer."),(0,o.kt)("p",null,"By creating a new Selector on each iteration of the ",(0,o.kt)("inlineCode",{parentName:"p"},"for")," loop, you're telling Temporal to handle the next update cart signal it receives or send an abandoned cart email if it doesn't receive a signal for ",(0,o.kt)("inlineCode",{parentName:"p"},"abandonedCartTimeout"),".\nCalling ",(0,o.kt)("inlineCode",{parentName:"p"},"Select()")," on a Selector blocks the Workflow until there's either a signal or ",(0,o.kt)("inlineCode",{parentName:"p"},"abandonedCartTimeout")," elapses."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'func CartWorkflow(ctx workflow.Context, state CartState) error {\n    logger := workflow.GetLogger(ctx)\n\n    err := workflow.SetQueryHandler(ctx, "getCart", func(input []byte) (CartState, error) {\n        return state, nil\n    })\n    if err != nil {\n        logger.Info("SetQueryHandler failed.", "Error", err)\n        return err\n    }\n\n    channel := workflow.GetSignalChannel(ctx, "cartMessages")\n    sentAbandonedCartEmail := false\n\n    for {\n    // Create a new Selector on each iteration of the loop means Temporal will pick the first\n    // event that occurs each time: either receiving a signal, or responding to the timer.\n        selector := workflow.NewSelector(ctx)\n        selector.AddReceive(channel, func(c workflow.ReceiveChannel, _ bool) {\n            var signal interface{}\n            c.Receive(ctx, &signal)\n\n            // Handle signals for updating the cart\n        })\n\n    // If the user doesn\'t update the cart for `abandonedCartTimeout`, send an email\n    // reminding them about their cart. Only send the email once.\n        if !sentAbandonedCartEmail && len(state.Items) > 0 {\n            selector.AddFuture(workflow.NewTimer(ctx, abandonedCartTimeout), func(f workflow.Future) {\n                sentAbandonedCartEmail = true\n                ao := workflow.ActivityOptions{\n                    StartToCloseTimeout:   10 * time.Second,\n                }\n\n                ctx = workflow.WithActivityOptions(ctx, ao)\n\n        // More on SendAbandonedCartEmail in the next section\n                err := workflow.ExecuteActivity(ctx, SendAbandonedCartEmail, state.Email).Get(ctx, nil)\n                if err != nil {\n                    logger.Error("Error sending email %v", err)\n                    return\n                }\n            })\n        }\n\n        selector.Select(ctx)\n    }\n\n    return nil\n}\n')),(0,o.kt)("p",null,"Temporal's ",(0,o.kt)("a",{parentName:"p",href:"https://docs.temporal.io/go/selectors/"},"GO SDK Selectors")," make it easy to orchestrate asynchronous signals in the Workflow logic, like responding to either user input or an abandoned cart timeout."),(0,o.kt)("p",null,"You do not need to implement a job queue, write a separate worker, or handle rescheduling jobs.\nAll you need to do is create a new Selector after every signal and use ",(0,o.kt)("inlineCode",{parentName:"p"},"AddFuture()")," to defer code that needs to happen after the associated timeout is selected."),(0,o.kt)("p",null,"Temporal does the hard work of persisting and distributing the state of your Workflow for you."),(0,o.kt)("p",null,"Next, let's take a closer look at Activities and the ",(0,o.kt)("inlineCode",{parentName:"p"},"ExecuteActivity()")," call above that is responsible for sending the abandoned cart email."),(0,o.kt)("h2",{id:"sending-emails-from-an-activity"},"Sending emails from an Activity"),(0,o.kt)("p",null,"You can think of Activities as an abstraction for side effects in Temporal.\n",(0,o.kt)("a",{parentName:"p",href:"https://docs.temporal.io/go-create-workflows/#implementation"},"Workflows should be pure, idempotent functions")," to allow Temporal to re-run a Workflow to recreate the Workflow's state.\nAny side effects, like HTTP requests to the ",(0,o.kt)("a",{parentName:"p",href:"https://thecodebarbarian.com/sending-emails-using-the-mailgun-api.html"},"Mailgun API"),", should be in an Activity."),(0,o.kt)("p",null,"For example, the following blob of code contains the implementation of the ",(0,o.kt)("inlineCode",{parentName:"p"},"SendAbandonedCartEmail()")," function.\nIt loads Mailgun keys from environment variables and sends an HTTP request to the Mailgun API using ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/mailgun/mailgun-go"},"Mailgun's official Go library"),".\nThe function takes two parameters: the Workflow context and the email as a string."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'import (\n    "context"\n    "fmt"\n    "github.com/mailgun/mailgun-go"\n)\n\nvar (\n    mailgunDomain = os.Getenv("MAILGUN_DOMAIN")\n    mailgunKey    = os.Getenv("MAILGUN_PRIVATE_KEY")\n)\n\nfunc SendAbandonedCartEmail(_ context.Context, email string) error {\n    mg := mailgun.NewMailgun(mailgunDomain, mailgunKey)\n    m := mg.NewMessage(\n        "noreply@"+mailgunDomain, // Sender\n        "You\'ve abandoned your shopping cart!", // Subject\n        "Go to http://localhost:8080 to finish checking out!", // Placeholder email copy\n        email, // Recipient\n    )\n    _, _, err := mg.Send(m)\n    if err != nil {\n        fmt.Println("Mailgun err: " + err.Error())\n    }\n\n    return err\n}\n')),(0,o.kt)("p",null,"As a reminder, the code below is the ",(0,o.kt)("inlineCode",{parentName:"p"},"ExecuteActivity()")," call from the cart Workflow.\nThe third parameter to ",(0,o.kt)("inlineCode",{parentName:"p"},"ExecuteActivity()")," becomes the second parameter to ",(0,o.kt)("inlineCode",{parentName:"p"},"SendAbandonedCartEmail()"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"workflow.ExecuteActivity(ctx, SendAbandonedCartEmail, state.Email).Get(ctx, nil)\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ExecuteActivity()")," function also exposes some neat options."),(0,o.kt)("p",null,"For example, since ",(0,o.kt)("a",{parentName:"p",href:"https://docs.temporal.io/retry-policies"},"Temporal automatically retries failed activities"),", it would automatically retry the ",(0,o.kt)("inlineCode",{parentName:"p"},"SendAbandonedCart()")," Activity for up to 5 times if ",(0,o.kt)("inlineCode",{parentName:"p"},"SendAbandonedCart()")," returns an error."),(0,o.kt)("p",null,"You can configure how long Temporal will take while attempting to execute your Activity (including setting a retry policy), with ",(0,o.kt)("inlineCode",{parentName:"p"},"ScheduleToCloseTimeout"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"ao := workflow.ActivityOptions{\n    StartToCloseTimeout: time.Minute,\n    ScheduleToCloseTimeout: time.Minute * 5,\n    RetryPolicy: &temporal.RetryPolicy{\n      InitialInterval:    time.Second,\n      BackoffCoefficient: 2.0,\n      MaximumInterval:    time.Minute,\n      MaximumAttempts:    5,\n    },\n}\n\nctx = workflow.WithActivityOptions(ctx, ao)\n\nerr := workflow.ExecuteActivity(ctx, SendAbandonedCartEmail, state.Email).Get(ctx, nil)\n")),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"Long-living Workflows in Temporal are excellent for scheduled tasks.\nYou can build durable time-based logic, like checking whether the user hasn't modified their shopping cart for a given period of time without using a job queue."),(0,o.kt)("p",null,"In the ",(0,o.kt)("a",{parentName:"p",href:"/tutorials/go/ecommerce/build-an-ecommerce-app-with-temporal-part-3-testing"},"next tutorial"),", you'll learn about patterns for unit testing Temporal Workflows."))}d.isMDXComponent=!0},161:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/banner_go-9b8733250036c66a86bf103fb4a01804.png"}}]);